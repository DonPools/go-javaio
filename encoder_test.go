package javaio

import (
	"bytes"
	"fmt"
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"
)

type List struct {
	Value int32
	Next  *List
}

func (*List) ClassName() string {
	return "List"
}

func (*List) SerialVersionUID() int64 {
	return 1
}

func TestEncoder_WriteObject_1(t *testing.T) {
	list2 := &List{
		Value: 19,
	}
	list1 := &List{
		Value: 17,
		Next:  list2,
	}

	var buf bytes.Buffer
	enc, err := NewEncoder(&buf)
	assert.NoError(t, err)
	assert.NoError(t, enc.writeObject(list1))
	assert.NoError(t, enc.writeObject(list2))
	assert.Equal(t, []byte{
		0xac, 0xed, 0x0, 0x5, 0x73, 0x72, 0x0, 0x4, 0x4c, 0x69, 0x73, 0x74, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x2, 0x0, 0x2,
		0x49, 0x0, 0x5, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x4c, 0x0, 0x4, 0x6e, 0x65, 0x78, 0x74, 0x74, 0x0, 0x6, 0x4c, 0x4c, 0x69,
		0x73, 0x74, 0x3b, 0x78, 0x70, 0x0, 0x0, 0x0, 0x11, 0x73, 0x71, 0x0, 0x7e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x13, 0x70, 0x71, 0x0,
		0x7e, 0x0, 0x3,
	}, buf.Bytes())
}

type A struct {
	super B

	IntValue    int32
	LongValue   int64
	StringValue *String
}

type B struct {
	SerializableValue *Serializable
}

func (A) ClassName() string {
	return "A"
}

func (A) SerialVersionUID() int64 {
	return 1
}

func (a *A) Super() interface{} {
	return &a.super
}

func (B) SerialVersionUID() int64 {
	return 1
}

func (B) ClassName() string {
	return "B"
}

func TestEncoder_WriteObject_2(t *testing.T) {
	a := &A{
		IntValue:    42,
		LongValue:   -42,
		StringValue: &String{Value: "foo"},
	}
	a.super.SerializableValue = &Serializable{Value: a}
	var buf bytes.Buffer
	enc, err := NewEncoder(&buf)
	assert.NoError(t, err)
	assert.NoError(t, enc.WriteObject(a))
	assert.Equal(t, []byte{
		0xac, 0xed, 0x00, 0x05, 0x73, 0x72, 0x00, 0x01, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x02, 0x00, 0x03, 0x49, 0x00, 0x08, 0x69, 0x6e, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x4a,
		0x00, 0x09, 0x6c, 0x6f, 0x6e, 0x67, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x4c, 0x00, 0x0b, 0x73, 0x74,
		0x72, 0x69, 0x6e, 0x67, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x74, 0x00, 0x12, 0x4c, 0x6a, 0x61, 0x76,
		0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x3b, 0x78, 0x72,
		0x00, 0x01, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x01, 0x4c, 0x00,
		0x11, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x62, 0x6c, 0x65, 0x56, 0x61, 0x6c,
		0x75, 0x65, 0x74, 0x00, 0x16, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x69, 0x6f, 0x2f, 0x53, 0x65,
		0x72, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x62, 0x6c, 0x65, 0x3b, 0x78, 0x70, 0x71, 0x00, 0x7e,
		0x00, 0x04, 0x00, 0x00, 0x00, 0x2a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd6, 0x74, 0x00,
		0x03, 0x66, 0x6f, 0x6f,
	}, buf.Bytes())
}

func TestEncoder_Write(t *testing.T) {
	list := &LinkedList{}
	list.Values = append(list.Values, &Swizzle{Object: &String{"30.208.43.86"}})
	var buf bytes.Buffer
	enc, _ := NewEncoder(&buf)
	if err := enc.WriteObject(list); err != nil {
		panic(err)
	}

	dec, _ := NewDecoder(&buf)
	type ClassName interface {
		ClassName() string
	}
	for _, typeValue := range []ClassName{
		LinkedList{},
		Swizzle{},
		String{},
	} {
		dec.RegisterType(typeValue.ClassName(), reflect.TypeOf(typeValue))
	}
	resp, err := dec.ReadObject()
	if err != nil {
		panic(err)
	}
	list = resp.(*LinkedList)
	assert.Equal(t, len(list.Values), 1)
	assert.Equal(t, list.Values[0].(*Swizzle).Object.(*String).Value, "30.208.43.86")
}

func TestNewEncoder(t *testing.T) {
	var reader bytes.Buffer
	enc, _ := NewEncoder(&reader)
	pkg := NewPackage()

	pkg.AddElement(NewPublisherDataElement(&String{Value: "D"}, &String{Value: "registry.Key()"}, &LinkedList{Values: []interface{}{&Swizzle{Object: &String{"127.0.0.1"}}}}))
	if err := enc.WriteObject(pkg); err != nil {
		t.Fatal(err)
	}
	assert.Equal(t, []byte{
		0xac, 0xed, 0x0, 0x5, 0x73, 0x72, 0x0, 0x31, 0x63, 0x6f, 0x6d, 0x2e, 0x74, 0x61, 0x6f, 0x62, 0x61, 0x6f, 0x2e, 0x63, 0x6f,
		0x6e, 0x66, 0x69, 0x67, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,
		0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x1, 0x2, 0x0, 0x0, 0x78, 0x72, 0x0, 0x30, 0x63, 0x6f, 0x6d, 0x2e, 0x74, 0x61, 0x6f, 0x62, 0x61, 0x6f, 0x2e, 0x63,
		0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f,
		0x6c, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0xcf, 0x8c, 0x97, 0xb7,
		0x9a, 0xcf, 0x41, 0x78, 0x3, 0x0, 0x0, 0x78, 0x70, 0x77, 0x8, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x64, 0x73, 0x72, 0x0,
		0x30, 0x63, 0x6f, 0x6d, 0x2e, 0x74, 0x61, 0x6f, 0x62, 0x61, 0x6f, 0x2e, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x63,
		0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x56, 0x65, 0x72, 0x73, 0x69,
		0x6f, 0x6e, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x2, 0x0, 0x3, 0x49, 0x0,
		0x5, 0x62, 0x75, 0x69, 0x6c, 0x64, 0x53, 0x0, 0x5, 0x6d, 0x61, 0x6a, 0x6f, 0x72, 0x53, 0x0, 0x5, 0x6d, 0x69, 0x6e, 0x6f,
		0x72, 0x78, 0x70, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x2, 0x77, 0x4, 0x0, 0x0, 0x0, 0x6a, 0x73, 0x72, 0x0, 0x36, 0x63, 0x6f,
		0x6d, 0x2e, 0x74, 0x61, 0x6f, 0x62, 0x61, 0x6f, 0x2e, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
		0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x73, 0x68, 0x65, 0x72, 0x44,
		0x61, 0x74, 0x61, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x2, 0x0, 0x1, 0x4c, 0x0,
		0x8, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x74, 0x0, 0x12, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67,
		0x2f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x3b, 0x78, 0x72, 0x0, 0x31, 0x63, 0x6f, 0x6d, 0x2e, 0x74, 0x61, 0x6f, 0x62, 0x61, 0x6f,
		0x2e, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f,
		0x6c, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x44, 0x61, 0x74, 0x61, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x1, 0x2, 0x0, 0x5, 0x5a, 0x0, 0x7, 0x6e, 0x65, 0x65, 0x64, 0x41, 0x63, 0x6b, 0x5b, 0x0, 0x9, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74,
		0x49, 0x64, 0x73, 0x74, 0x0, 0x13, 0x5b, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x53, 0x74, 0x72, 0x69,
		0x6e, 0x67, 0x3b, 0x4c, 0x0, 0x4, 0x64, 0x61, 0x74, 0x61, 0x74, 0x0, 0x16, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x75, 0x74, 0x69, 0x6c,
		0x2f, 0x4c, 0x69, 0x6e, 0x6b, 0x65, 0x64, 0x4c, 0x69, 0x73, 0x74, 0x3b, 0x4c, 0x0, 0x6, 0x64, 0x61, 0x74, 0x61, 0x49, 0x64, 0x71, 0x0,
		0x7e, 0x0, 0x6, 0x4c, 0x0, 0x8, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x74, 0x0, 0x23, 0x4c, 0x63, 0x6f, 0x6d, 0x2f, 0x74,
		0x61, 0x6f, 0x62, 0x61, 0x6f, 0x2f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x52, 0x65,
		0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x3b, 0x78, 0x70, 0x1, 0x75, 0x72, 0x0, 0x13, 0x5b, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2e, 0x6c,
		0x61, 0x6e, 0x67, 0x2e, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x3b, 0x43, 0xbc, 0xed, 0x3, 0x1d, 0xbc, 0x8, 0xdd, 0x2, 0x0, 0x0,
		0x78, 0x70, 0x0, 0x0, 0x0, 0x1, 0x74, 0x0, 0xe, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x2e, 0x4b, 0x65, 0x79, 0x28,
		0x29, 0x73, 0x72, 0x0, 0x14, 0x6a, 0x61, 0x76, 0x61, 0x2e, 0x75, 0x74, 0x69, 0x6c, 0x2e, 0x4c, 0x69, 0x6e, 0x6b, 0x65, 0x64,
		0x4c, 0x69, 0x73, 0x74, 0xc, 0x29, 0x53, 0x5d, 0x4a, 0x60, 0x88, 0x22, 0x3, 0x0, 0x0, 0x78, 0x70, 0x77, 0x4, 0x0, 0x0, 0x0,
		0x1, 0x73, 0x72, 0x0, 0x29, 0x63, 0x6f, 0x6d, 0x2e, 0x74, 0x61, 0x6f, 0x62, 0x61, 0x6f, 0x2e, 0x63, 0x6f, 0x6e, 0x66, 0x69,
		0x67, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x53, 0x77, 0x69,
		0x7a, 0x7a, 0x6c, 0x65, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x3, 0x0, 0x3, 0x49, 0x0, 0xd, 0x73, 0x65, 0x72, 0x69, 0x61,
		0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5b, 0x0, 0x5, 0x62, 0x79, 0x74, 0x65, 0x73, 0x74, 0x0, 0x2, 0x5b, 0x42, 0x4c,
		0x0, 0x6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x71, 0x0, 0x7e, 0x0, 0x6, 0x78, 0x70, 0x77, 0x15, 0x1, 0x0, 0x0, 0x0, 0x10, 0xac,
		0xed, 0x0, 0x5, 0x74, 0x0, 0x9, 0x31, 0x32, 0x37, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x31, 0x78, 0x78, 0x74, 0x0, 0x1, 0x44, 0x73,
		0x72, 0x0, 0x21, 0x63, 0x6f, 0x6d, 0x2e, 0x74, 0x61, 0x6f, 0x62, 0x61, 0x6f, 0x2e, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e,
		0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x1, 0x2, 0x0, 0x1, 0x4a, 0x0, 0x8, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x78, 0x70, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x2, 0x71, 0x0, 0x7e, 0x0, 0xd, 0x78,
	}, reader.Bytes())
}

type Packet struct {
	elements []Element
}

type Package struct {
	super Packet
}

type Element interface {
	UID() int32
}

type AttrElement struct {
	Name  *String
	Value *Serializable
}

type RegReqPacket struct {
	super Packet
}

type RegElement struct {
	Client *String `javaio:"client"`
	Data   *String `javaio:"data"`
	Datum  *String `javaio:"datum"`
}

type Version struct {
	Build int32
	Major int16
	Minor int16
}

func NewPackage() *Package {
	pkg := &Package{}
	pkg.AddElement(&Version{
		Major: 1,
		Minor: 2,
		Build: 0,
	})
	return pkg
}

func (Packet) ClassName() string {
	return "cn.Packet"
}

func (Packet) SerialVersionUID() int64 {
	return -3491248796286893704
}

func (packet *Packet) AddElement(element Element) {
	packet.elements = append(packet.elements, element)
}

func (packet *Packet) ReadObject(dec *Decoder) error {
	var count int32
	if err := dec.ReadBinary(&count); err != nil {
		return err
	}
	if count < 0 {
		return fmt.Errorf("Packet: ReadObject: invalid count %d", count)
	}
	for i := 0; i < int(count); i++ {
		var uid int32
		if err := dec.ReadBinary(&uid); err != nil {
			return err
		}
		object, err := dec.ReadObject()
		if err != nil {
			return err
		}
		element, ok := object.(Element)
		if !ok {
			return fmt.Errorf("Packet: ReadObject: expected Element, got %s", reflect.TypeOf(object))
		}
		packet.elements = append(packet.elements, element)
	}
	return nil
}

func (packet *Packet) WriteObject(w *Encoder) error {
	if err := w.WriteObject(int32(len(packet.elements))); err != nil {
		return err
	}
	for _, element := range packet.elements {
		if err := w.WriteObject(element.UID()); err != nil {
			return err
		}
		if err := w.WriteObject(element); err != nil {
			return err
		}
	}
	return nil
}

func (Package) ClassName() string {
	return "cn.Package"
}

func (Package) SerialVersionUID() int64 {
	return 1
}

func (pkg *Package) Super() interface{} {
	return &pkg.super
}

func (pkg *Package) AddElement(element Element) {
	pkg.super.AddElement(element)
}

func (pkg *Package) Elements() []Element {
	return pkg.super.elements
}

func NewAttrElementString(name, value string) *AttrElement {
	return &AttrElement{
		Name:  &String{Value: name},
		Value: &Serializable{Value: &String{Value: value}},
	}
}

func (attr AttrElement) ClassName() string {
	return "cn.AttrElement"
}

func (attr AttrElement) SerialVersionUID() int64 {
	return 1
}

func (attr *AttrElement) WriteObject(w *Encoder) error {
	if err := w.WriteObject(attr.Name); err != nil {
		return err
	}
	if err := w.WriteObject(attr.Value); err != nil {
		return err
	}
	return nil
}

func (AttrElement) UID() int32 {
	return 122 // ELEMENT_ATTRIBUTE
}

func (RegReqPacket) ClassName() string {
	return "cn.RegReqPacket"
}

func (RegReqPacket) SerialVersionUID() int64 {
	return 2599767358714732354
}

func (packet RegReqPacket) Super() interface{} {
	return &packet.super
}

func (packet *RegReqPacket) SetAttribute(name *String, value *Serializable) {
	for i := range packet.super.elements {
		element, ok := packet.super.elements[i].(*AttrElement)
		if !ok {
			continue
		}
		if element.Name == name {
			if value == nil {
				packet.super.elements = append(packet.super.elements[:i], packet.super.elements[i+1:]...)
			} else {
				element.Value = value
			}
			continue
		}
	}
	if value == nil {
		return
	}
	packet.super.AddElement(&AttrElement{
		Name:  name,
		Value: value,
	})
}

func (Version) ClassName() string {
	return "cn.Version"
}

func (Version) SerialVersionUID() int64 {
	return 1
}

func (Version) UID() int32 {
	return 100 // ELEMENT_VERSION
}

type UserData struct {
	ID       *String   `javaio:"id"`
	Revision *Revision `javaio:"revision"`
	IDs      *Array    `javaio:"ids"`
	Data     *LinkedList
	Ack      bool `javaio:"ack"`
}

func (UserData) ClassName() string {
	return "cn.UserData"
}

func (UserData) SerialVersionUID() int64 {
	return 1
}

func (UserData) UID() int32 {
	return 104 // ELEMENT_USER_DATA
}

func (u *UserData) ClientID() (string, bool) {
	if u.IDs.Len() == 0 {
		return "", false
	}
	clientID := u.IDs.Index(0)
	clientIDString, ok := clientID.(*String)
	if !ok {
		return "", false
	}
	if clientIDString == nil {
		return "", false
	}
	return clientIDString.Value, true
}

func (u *UserData) UnwrappedValues() (result []interface{}) {
	if u.Data == nil {
		return
	}
	result = make([]interface{}, 0, len(u.Data.Values))
	for _, value := range u.Data.Values {
		if swizzle, isSwizzle := value.(*Swizzle); isSwizzle {
			value = swizzle.Object
		}
		result = append(result, value)
	}
	return
}

type Publisher struct {
	super UserData
	Id    *String `javaio:"id"`
}

func (Publisher) ClassName() string {
	return "cn.Publisher"
}

func (Publisher) SerialVersionUID() int64 {
	return 1
}

func (Publisher) UID() int32 {
	return 106 // ELEMENT_PUBLISHER_DATA
}

func (p *Publisher) Super() interface{} {
	return &p.super
}

func (p *Publisher) ClientID() (string, bool) {
	return p.super.ClientID()
}

func NewPublisherDataElement(dataId *String, clientId *String, data *LinkedList) Element {
	return &Publisher{
		super: UserData{
			Ack:      true,
			ID:       dataId,
			Data:     data,
			IDs:      NewArray([]*String{clientId}),
			Revision: &Revision{2},
		},
		Id: clientId,
	}
}

type LinkedList struct {
	Values []interface{} `javaio:"-"`
}

func (LinkedList) ClassName() string {
	return "java.util.LinkedList"
}

func (LinkedList) SerialVersionUID() int64 {
	return 876323262645176354
}

func (list *LinkedList) ReadObject(dec *Decoder) error {
	var l int32
	if err := dec.ReadBinary(&l); err != nil {
		return err
	}
	for i := 0; i < int(l); i++ {
		object, err := dec.ReadObject()
		if err != nil {
			return err
		}
		list.Values = append(list.Values, object)
	}
	return nil
}

func (list *LinkedList) WriteObject(enc *Encoder) error {
	if err := enc.WriteObject(int32(len(list.Values))); err != nil {
		return err
	}
	for _, val := range list.Values {
		if err := enc.WriteObject(val); err != nil {
			return err
		}
	}
	return nil
}

type Swizzle struct {
	Serialization int32  `javaio:"serialization"`
	Bytes         []byte `javaio:"bytes"`
	Object        interface{}
}

func (Swizzle) ClassName() string {
	return "cn.Swizzle"
}

func (Swizzle) SerialVersionUID() int64 {
	return 1
}

func (s *Swizzle) ReadObject(dec *Decoder) error {
	var (
		serialization byte
		l             int32
	)
	if err := dec.ReadBinary(&serialization, &l); err != nil {
		return err
	}
	if l < 0 {
		return fmt.Errorf("ReadObject: invalid size %d", l)
	}
	p := make([]byte, l)
	_, err := dec.Read(p)
	if err != nil {
		return err
	}
	pDec, err := NewDecoder(bytes.NewReader(p))
	if err != nil {
		return err
	}
	object, err := pDec.ReadObject()
	if err != nil {
		return err
	}
	s.Object = object
	return nil
}

func (s Swizzle) WriteObject(enc *Encoder) error {
	if err := enc.WriteObject(byte(1)); err != nil {
		return err
	}
	var buf bytes.Buffer
	encoder, err := NewEncoder(&buf)
	if err != nil {
		return err
	}
	if err = encoder.WriteObject(s.Object); err != nil {
		return err
	}
	if err = enc.WriteObject(int32(buf.Len())); err != nil {
		return err
	}
	_, err = enc.Write(buf.Bytes())
	return err
}

type Revision struct {
	Revision int64 `javaio:"revision"`
}

func (Revision) ClassName() string {
	return "com.taobao.config.common.Revision"
}

func (Revision) SerialVersionUID() int64 {
	return 1
}

type PublisherPacket struct {
	super RegReqPacket
}

func (PublisherPacket) ClassName() string {
	return "cn.PublisherPacket"
}

func (PublisherPacket) SerialVersionUID() int64 {
	return 1
}

func (p *PublisherPacket) Super() interface{} {
	return &p.super
}

func (p *PublisherPacket) SetAttribute(name *String, value *Serializable) {
	p.super.SetAttribute(name, value)
}

func (PublisherPacket) UID() int32 {
	return 10 // PACKET_PUBLISHER_REG_REQUEST
}
